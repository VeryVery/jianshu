# jvm内存模型

Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分

* 程序计数器（***线程私有***）
    * 当前线程所执行的字节码的**行号**指示器,***字节码解释器通过改变程序计数器来依次读取指令***，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
    * 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。每条线程都有一个程序计数器，生命周期随着线程的创建而创建，随着线程的结束而死亡 
    * 如果正在执行的是**Natvie**方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域

---

* Java虚拟机栈(JVM Stack)（***线程私有***）
    *  线程私有，它的生命周期与线程相同
    *  每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储***局部变量***（boolean、int等）、***操作栈***、动态链接、方法出口等**编译期可知**的信息，**只存自定义对象的引用**
    *  Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError
        *  StackOverFlowError： 当线程请求栈的深度超过当前Java虚拟机栈的最大深度
        *  OutOfMemoryError：当线程请求栈时内存用完了，无法再动态扩展了

---

* 本地方法栈
    * 与上面栈所发挥的作用是相似，区别：
        * 虚拟机栈为虚拟机执行Java 方法服务
        * 本地方法栈则是为虚拟机使用到的Native 方法服务
        *  Native：native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中，通过JNI调用

---

* 堆(JVM Heap)（***线程公有***）
    * Java 虚拟机所管理的内存中最大的一块
    * 被所有线程共享内存区域，存放对象实例，堆中不存放基本类型和对象引用
    * 堆可以处于物理上不连续的内存空间中，可扩展
    * Java 堆中还可以细分为：**新生代**和**老年代**（分代的唯一理由就是优化GC性能）,永久代
        * 新生代分为了三部分：1个Eden区和2个Survivor区；**Edem : from : to = 8 : 1 : 1**
        * JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着
        * 新创建的对象都会被分配到Eden区(一些大对象特殊处理),经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中

---

* 方法区（***线程公有***）
    * 方法区中存放类信息、常量、静态变量、即时编译器编译的代码

---

* 运行时常量池
    *  常量存储，比如：public static final来声明一个常量

---
##总结
* 栈是运行时的单位，而堆是存储的单位。
* 一个线程就会相应有一个线程栈与之对应
* 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据
* 堆解决的是数据存储的问题，即数据怎么放、放在哪儿

##Sample
Object obj = newObject();

* "Object obj" 反映到Java栈的本地变量表中，作为一个reference类型数据出现
* "new Object()"这部分的语义将会反映到Java 堆中，作为一个实例数据值Instance Data
* 对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中